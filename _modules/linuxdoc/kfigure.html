
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>linuxdoc.kfigure &#8212; LinuxDoc 20210324 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/tabs.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <script>DOCUMENTATION_OPTIONS.URL_ROOT = '../../';</script>
   
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">LinuxDoc 20210324 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">linuxdoc.kfigure</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for linuxdoc.kfigure</h1><div class="highlight"><pre>
<span></span># -*- coding: utf-8; mode: python -*-
# pylint: disable=invalid-name, missing-docstring, too-many-branches
# pylint: disable=unnecessary-pass
# SPDX-License-Identifier: GPL-2.0
&quot;&quot;&quot;\
scalable figure and image handling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sphinx extension which implements scalable image handling.
User documentation see :ref:`kfigure`
&quot;&quot;&quot;

import os
from os import path
import subprocess
from hashlib import sha1
import logging

from docutils import nodes
from docutils.statemachine import ViewList
from docutils.parsers.rst import directives
from docutils.parsers.rst.directives import images

from sphinx.util.nodes import clean_astext
from six import iteritems

__version__  = &#39;3.0&#39;

app_log = logging.getLogger(&#39;application&#39;)

# simple helper
# -------------

<div class="viewcode-block" id="which"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.which">[docs]</a>def which(cmd):  # pylint: disable=inconsistent-return-statements
    &quot;&quot;&quot;Searches the ``cmd`` in the ``PATH`` environment.

    This *which* searches the PATH for executable ``cmd`` . First match is
    returned, if nothing is found, ``None`` is returned.
    &quot;&quot;&quot;
    envpath = os.environ.get(&#39;PATH&#39;, None) or os.defpath
    for folder in envpath.split(os.pathsep):
        fname = folder + os.sep + cmd
        if path.isfile(fname):
            return fname</div>

<div class="viewcode-block" id="mkdir"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.mkdir">[docs]</a>def mkdir(folder, mode=0o775):
    if not path.isdir(folder):
        os.makedirs(folder, mode)</div>

<div class="viewcode-block" id="file2literal"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.file2literal">[docs]</a>def file2literal(fname):
    with open(fname, &quot;r&quot;) as src:
        data = src.read()
        node = nodes.literal_block(data, data)
    return node</div>

<div class="viewcode-block" id="isNewer"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.isNewer">[docs]</a>def isNewer(path1, path2):
    &quot;&quot;&quot;Returns True if ``path1`` is newer than ``path2``

    If ``path1`` exists and is newer than ``path2`` the function returns
    ``True`` is returned otherwise ``False``
    &quot;&quot;&quot;
    return (path.exists(path1)
            and os.stat(path1).st_ctime &gt; os.stat(path2).st_ctime)</div>

<div class="viewcode-block" id="pass_handle"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.pass_handle">[docs]</a>def pass_handle(self, node):  # pylint: disable=unused-argument
    pass</div>

# setup conversion tools and sphinx extension
# -------------------------------------------

# Graphviz&#39;s dot(1) support
dot_cmd = None

# ImageMagick&#39; convert(1) support
convert_cmd = None


<div class="viewcode-block" id="setup"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.setup">[docs]</a>def setup(app):
    # check toolchain first
    app.connect(&#39;builder-inited&#39;, setupTools)

    # image handling
    app.add_directive(&quot;kernel-image&quot;,  KernelImage)
    app.add_node(kernel_image,
                 html    = (visit_kernel_image, pass_handle),
                 latex   = (visit_kernel_image, pass_handle),
                 texinfo = (visit_kernel_image, pass_handle),
                 text    = (visit_kernel_image, pass_handle),
                 man     = (visit_kernel_image, pass_handle), )

    # figure handling
    app.add_directive(&quot;kernel-figure&quot;, KernelFigure)
    app.add_node(kernel_figure,
                 html    = (visit_kernel_figure, pass_handle),
                 latex   = (visit_kernel_figure, pass_handle),
                 texinfo = (visit_kernel_figure, pass_handle),
                 text    = (visit_kernel_figure, pass_handle),
                 man     = (visit_kernel_figure, pass_handle), )

    # render handling
    app.add_directive(&#39;kernel-render&#39;, KernelRender)
    app.add_node(kernel_render,
                 html    = (visit_kernel_render, pass_handle),
                 latex   = (visit_kernel_render, pass_handle),
                 texinfo = (visit_kernel_render, pass_handle),
                 text    = (visit_kernel_render, pass_handle),
                 man     = (visit_kernel_render, pass_handle), )

    app.connect(&#39;doctree-read&#39;, add_kernel_figure_to_std_domain)

    return dict(
        version = __version__,
        parallel_read_safe = True,
        parallel_write_safe = True
    )</div>


<div class="viewcode-block" id="setupTools"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.setupTools">[docs]</a>def setupTools(app): # pylint: disable=unused-argument
    u&quot;&quot;&quot;
    Check available build tools and log some *verbose* messages.

    This function is called once, when the builder is initiated.
    &quot;&quot;&quot;
    global dot_cmd, convert_cmd  # pylint: disable=global-statement

    # pylint: disable=deprecated-method
    app_log.info(&quot;kfigure: check installed tools ...&quot;)

    dot_cmd = which(&#39;dot&#39;)
    convert_cmd = which(&#39;convert&#39;)

    if dot_cmd:
        app_log.info(&quot;use dot(1) from: %s&quot;,  dot_cmd)
    else:
        app_log.warn(&quot;dot(1) not found, for better output quality install &quot;
                     &quot;graphviz from http://www.graphviz.org&quot;)
    if convert_cmd:
        app_log.info(&quot;use convert(1) from: %s&quot;, convert_cmd)
    else:
        app_log.warn(
            &quot;convert(1) not found, for SVG to PDF conversion install &quot;
            &quot;ImageMagick (https://www.imagemagick.org)&quot;)</div>


# integrate conversion tools
# --------------------------

RENDER_MARKUP_EXT = {
    # The &#39;.ext&#39; must be handled by convert_image(..) function&#39;s *in_ext* input.
    # &lt;name&gt; : &lt;.ext&gt;
    &#39;DOT&#39; : &#39;.dot&#39;,
    &#39;SVG&#39; : &#39;.svg&#39;
}

<div class="viewcode-block" id="convert_image"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.convert_image">[docs]</a>def convert_image(img_node, translator, src_fname=None):
    &quot;&quot;&quot;Convert a image node for the builder.

    Different builder prefer different image formats, e.g. *latex* builder
    prefer PDF while *html* builder prefer SVG format for images.

    This function handles output image formats in dependence of source the
    format (of the image) and the translator&#39;s output format.
    &quot;&quot;&quot;
    app = translator.builder.app

    fname, in_ext = path.splitext(path.basename(img_node[&#39;uri&#39;]))
    if src_fname is None:
        src_fname = path.join(translator.builder.srcdir, img_node[&#39;uri&#39;])
        if not path.exists(src_fname):
            src_fname = path.join(translator.builder.outdir, img_node[&#39;uri&#39;])

    dst_fname = None

    # in kernel builds, use &#39;make SPHINXOPTS=-v&#39; to see verbose messages

    app_log.info(&#39;assert best format for: %s&#39;, img_node[&#39;uri&#39;])

    if in_ext == &#39;.dot&#39;:

        if not dot_cmd:
            app_log.info(&quot;dot from graphviz not available / include DOT raw.&quot;)
            img_node.replace_self(file2literal(src_fname))

        elif translator.builder.format == &#39;latex&#39;:
            dst_fname = path.join(translator.builder.outdir, fname + &#39;.pdf&#39;)
            img_node[&#39;uri&#39;] = fname + &#39;.pdf&#39;
            img_node[&#39;candidates&#39;] = {&#39;*&#39;: fname + &#39;.pdf&#39;}


        elif translator.builder.format == &#39;html&#39;:
            dst_fname = path.join(
                translator.builder.outdir,
                translator.builder.imagedir,
                fname + &#39;.svg&#39;)
            img_node[&#39;uri&#39;] = path.join(
                translator.builder.imgpath, fname + &#39;.svg&#39;)
            img_node[&#39;candidates&#39;] = {
                &#39;*&#39;: path.join(translator.builder.imgpath, fname + &#39;.svg&#39;)}

        else:
            # all other builder formats will include DOT as raw
            img_node.replace_self(file2literal(src_fname))

    elif in_ext == &#39;.svg&#39;:

        if translator.builder.format == &#39;latex&#39;:
            if convert_cmd is None:
                app_log.info(&quot;no SVG to PDF conversion available / include SVG raw.&quot;)
                img_node.replace_self(file2literal(src_fname))
            else:
                dst_fname = path.join(translator.builder.outdir, fname + &#39;.pdf&#39;)
                img_node[&#39;uri&#39;] = fname + &#39;.pdf&#39;
                img_node[&#39;candidates&#39;] = {&#39;*&#39;: fname + &#39;.pdf&#39;}

    if dst_fname:
        # the builder needs not to copy one more time, so pop it if exists.
        translator.builder.images.pop(img_node[&#39;uri&#39;], None)
        _name = dst_fname[len(translator.builder.outdir) + 1:]

        if isNewer(dst_fname, src_fname):
            app_log.info(&quot;convert: {out}/%s already exists and is newer&quot;, _name)

        else:
            ok = False
            mkdir(path.dirname(dst_fname))

            if in_ext == &#39;.dot&#39;:
                app_log.info(&#39;convert DOT to: {out}/%s&#39;, _name)
                ok = dot2format(app, src_fname, dst_fname)

            elif in_ext == &#39;.svg&#39;:
                app_log.info(&#39;convert SVG to: {out}/%s&#39;, _name)
                ok = svg2pdf(app, src_fname, dst_fname)

            if not ok:
                img_node.replace_self(file2literal(src_fname))</div>


<div class="viewcode-block" id="dot2format"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.dot2format">[docs]</a>def dot2format(app, dot_fname, out_fname): # pylint: disable=unused-argument
    &quot;&quot;&quot;Converts DOT file to ``out_fname`` using ``dot(1)``.

    * ``dot_fname`` pathname of the input DOT file, including extension ``.dot``
    * ``out_fname`` pathname of the output file, including format extension

    The *format extension* depends on the ``dot`` command (see ``man dot``
    option ``-Txxx``). Normally you will use one of the following extensions:

    - ``.ps`` for PostScript,
    - ``.svg`` or ``svgz`` for Structured Vector Graphics,
    - ``.fig`` for XFIG graphics and
    - ``.png`` or ``gif`` for common bitmap graphics.

    &quot;&quot;&quot;
    out_format = path.splitext(out_fname)[1][1:]
    cmd = [dot_cmd, &#39;-T%s&#39; % out_format, dot_fname]
    exit_code = 42

    with open(out_fname, &quot;w&quot;) as out:
        exit_code = subprocess.call(cmd, stdout = out)
        if exit_code != 0:
            # pylint: disable=deprecated-method
            app_log.warn(&quot;Error #%d when calling: %s&quot;, exit_code, &quot; &quot;.join(cmd))
    return bool(exit_code == 0)</div>

<div class="viewcode-block" id="svg2pdf"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.svg2pdf">[docs]</a>def svg2pdf(app, svg_fname, pdf_fname): # pylint: disable=unused-argument
    &quot;&quot;&quot;Converts SVG to PDF with ``convert(1)`` command.

    Uses ``convert(1)`` from ImageMagick (https://www.imagemagick.org) for
    conversion.  Returns ``True`` on success and ``False`` if an error occurred.

    * ``svg_fname`` pathname of the input SVG file with extension (``.svg``)
    * ``pdf_name``  pathname of the output PDF file with extension (``.pdf``)

    &quot;&quot;&quot;
    cmd = [convert_cmd, svg_fname, pdf_fname]
    # use stdout and stderr from parent
    exit_code = subprocess.call(cmd)
    if exit_code != 0:
        # pylint: disable=deprecated-method
        app_log.warn(&quot;Error #%d when calling: %s&quot;, exit_code, &quot; &quot;.join(cmd))
    return bool(exit_code == 0)</div>


# image handling
# ---------------------

<div class="viewcode-block" id="visit_kernel_image"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.visit_kernel_image">[docs]</a>def visit_kernel_image(self, node):
    &quot;&quot;&quot;Visitor of the ``kernel_image`` Node.

    Handles the ``image`` child-node with the ``convert_image(...)``.
    &quot;&quot;&quot;
    img_node = node[0]
    convert_image(img_node, self)</div>

<div class="viewcode-block" id="kernel_image"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.kernel_image">[docs]</a>class kernel_image(nodes.image):
    &quot;&quot;&quot;Node for ``kernel-image`` directive.&quot;&quot;&quot;
    pass</div>

<div class="viewcode-block" id="KernelImage"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.KernelImage">[docs]</a>class KernelImage(images.Image):
    u&quot;&quot;&quot;KernelImage directive

    Earns everything from ``.. image::`` directive, except *remote URI* and
    *glob* pattern. The KernelImage wraps a image node into a
    kernel_image node. See ``visit_kernel_image``.
    &quot;&quot;&quot;

<div class="viewcode-block" id="KernelImage.run"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.KernelImage.run">[docs]</a>    def run(self):
        uri = self.arguments[0]
        if uri.endswith(&#39;.*&#39;) or uri.find(&#39;://&#39;) != -1:
            raise self.severe(
                &#39;Error in &quot;%s: %s&quot;: glob pattern and remote images are not allowed&#39;
                % (self.name, uri))
        result = images.Image.run(self)
        if len(result) == 2 or isinstance(result[0], nodes.system_message):
            return result
        (image_node,) = result
        # wrap image node into a kernel_image node / see visitors
        node = kernel_image(&#39;&#39;, image_node)
        return [node]</div></div>

# figure handling
# ---------------------

<div class="viewcode-block" id="visit_kernel_figure"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.visit_kernel_figure">[docs]</a>def visit_kernel_figure(self, node):
    &quot;&quot;&quot;Visitor of the ``kernel_figure`` Node.

    Handles the ``image`` child-node with the ``convert_image(...)``.
    &quot;&quot;&quot;
    img_node = node[0][0]
    convert_image(img_node, self)</div>

<div class="viewcode-block" id="kernel_figure"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.kernel_figure">[docs]</a>class kernel_figure(nodes.figure):
    &quot;&quot;&quot;Node for ``kernel-figure`` directive.&quot;&quot;&quot;</div>

<div class="viewcode-block" id="KernelFigure"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.KernelFigure">[docs]</a>class KernelFigure(images.Figure):
    u&quot;&quot;&quot;KernelImage directive

    Earns everything from ``.. figure::`` directive, except *remote URI* and
    *glob* pattern.  The KernelFigure wraps a figure node into a kernel_figure
    node. See ``visit_kernel_figure``.
    &quot;&quot;&quot;

<div class="viewcode-block" id="KernelFigure.run"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.KernelFigure.run">[docs]</a>    def run(self):
        uri = self.arguments[0]
        if uri.endswith(&#39;.*&#39;) or uri.find(&#39;://&#39;) != -1:
            raise self.severe(
                &#39;Error in &quot;%s: %s&quot;:&#39;
                &#39; glob pattern and remote images are not allowed&#39;
                % (self.name, uri))
        result = images.Figure.run(self)
        if len(result) == 2 or isinstance(result[0], nodes.system_message):
            return result
        (figure_node,) = result
        # wrap figure node into a kernel_figure node / see visitors
        node = kernel_figure(&#39;&#39;, figure_node)
        return [node]</div></div>


# render handling
# ---------------------

<div class="viewcode-block" id="visit_kernel_render"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.visit_kernel_render">[docs]</a>def visit_kernel_render(self, node):
    &quot;&quot;&quot;Visitor of the ``kernel_render`` Node.

    If rendering tools available, save the markup of the ``literal_block`` child
    node into a file and replace the ``literal_block`` node with a new created
    ``image`` node, pointing to the saved markup file. Afterwards, handle the
    image child-node with the ``convert_image(...)``.
    &quot;&quot;&quot;
    srclang = node.get(&#39;srclang&#39;)

    app_log.info(&#39;visit kernel-render node lang: &quot;%s&quot;&#39;, srclang)

    tmp_ext = RENDER_MARKUP_EXT.get(srclang, None)
    if tmp_ext is None:
        app_log.warning(&#39;kernel-render: &quot;%s&quot; unknown / include raw&#39;, srclang)
        return

    if not dot_cmd and tmp_ext == &#39;.dot&#39;:
        app_log.info(&quot;dot from graphviz not available / include raw.&quot;)
        return

    literal_block = node[0]

    code      = literal_block.astext()
    hashobj   = code.encode(&#39;utf-8&#39;) #  str(node.attributes)
    fname     = path.join(&#39;%s-%s&#39; % (srclang, sha1(hashobj).hexdigest()))

    tmp_fname = path.join(
        self.builder.outdir, self.builder.imagedir, fname + tmp_ext)

    if not path.isfile(tmp_fname):
        mkdir(path.dirname(tmp_fname))
        with open(tmp_fname, &quot;w&quot;) as out:
            out.write(code)

    img_node = nodes.image(node.rawsource, **node.attributes)
    img_node[&#39;uri&#39;] = path.join(self.builder.imgpath, fname + tmp_ext)
    img_node[&#39;candidates&#39;] = {
        &#39;*&#39;: path.join(self.builder.imgpath, fname + tmp_ext)}

    literal_block.replace_self(img_node)
    convert_image(img_node, self, tmp_fname)</div>


<div class="viewcode-block" id="kernel_render"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.kernel_render">[docs]</a>class kernel_render(nodes.General, nodes.Inline, nodes.Element):
    &quot;&quot;&quot;Node for ``kernel-render`` directive.&quot;&quot;&quot;
    pass</div>

<div class="viewcode-block" id="KernelRender"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.KernelRender">[docs]</a>class KernelRender(images.Figure):
    u&quot;&quot;&quot;KernelRender directive

    Render content by external tool.  Has all the options known from the
    *figure*  directive, plus option ``caption``.  If ``caption`` has a
    value, a figure node with the *caption* is inserted. If not, a image node is
    inserted.

    The KernelRender directive wraps the text of the directive into a
    literal_block node and wraps it into a kernel_render node. See
    ``visit_kernel_render``.
    &quot;&quot;&quot;
    has_content = True
    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = False

    # earn options from &#39;figure&#39;
    option_spec = images.Figure.option_spec.copy()
    option_spec[&#39;caption&#39;] = directives.unchanged

<div class="viewcode-block" id="KernelRender.run"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.KernelRender.run">[docs]</a>    def run(self):
        return [self.build_node()]</div>

<div class="viewcode-block" id="KernelRender.build_node"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.KernelRender.build_node">[docs]</a>    def build_node(self):

        srclang = self.arguments[0].strip()
        if srclang not in RENDER_MARKUP_EXT.keys():
            return [self.state_machine.reporter.warning(
                &#39;Unknown source language &quot;%s&quot;, use one of: %s.&#39; % (
                    srclang, &quot;,&quot;.join(RENDER_MARKUP_EXT.keys())),
                line=self.lineno)]

        code = &#39;\n&#39;.join(self.content)
        if not code.strip():
            return [self.state_machine.reporter.warning(
                &#39;Ignoring &quot;%s&quot; directive without content.&#39; % (
                    self.name),
                line=self.lineno)]

        node = kernel_render()
        node[&#39;alt&#39;] = self.options.get(&#39;alt&#39;,&#39;&#39;)
        node[&#39;srclang&#39;] = srclang
        literal_node = nodes.literal_block(code, code)
        node += literal_node

        caption = self.options.get(&#39;caption&#39;)
        if caption:
            # parse caption&#39;s content
            parsed = nodes.Element()
            self.state.nested_parse(
                ViewList([caption], source=&#39;&#39;), self.content_offset, parsed)
            caption_node = nodes.caption(
                parsed[0].rawsource, &#39;&#39;, *parsed[0].children)
            caption_node.source = parsed[0].source
            caption_node.line = parsed[0].line

            figure_node = nodes.figure(&#39;&#39;, node)
            for k,v in self.options.items():
                figure_node[k] = v
            figure_node += caption_node

            node = figure_node

        return node</div></div>

<div class="viewcode-block" id="add_kernel_figure_to_std_domain"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.kfigure.html#linuxdoc.kfigure.add_kernel_figure_to_std_domain">[docs]</a>def add_kernel_figure_to_std_domain(app, doctree):
    &quot;&quot;&quot;Add kernel-figure anchors to &#39;std&#39; domain.

    The ``StandardDomain.process_doc(..)`` method does not know how to resolve
    the caption (label) of ``kernel-figure`` directive (it only knows about
    standard nodes, e.g. table, figure etc.). Without any additional handling
    this will result in a &#39;undefined label&#39; for kernel-figures.

    This handle adds labels of kernel-figure to the &#39;std&#39; domain labels.
    &quot;&quot;&quot;

    std = app.env.domains[&quot;std&quot;]
    docname = app.env.docname
    labels = std.data[&quot;labels&quot;]

    for name, explicit in iteritems(doctree.nametypes):
        if not explicit:
            continue
        labelid = doctree.nameids[name]
        if labelid is None:
            continue
        node = doctree.ids[labelid]

        if node.tagname == &#39;kernel_figure&#39;:
            for n in node.next_node():
                if n.tagname == &#39;caption&#39;:
                    sectname = clean_astext(n)
                    # add label to std domain
                    labels[name] = docname, labelid, sectname
                    break</div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
  <span id="sidebar-top"></span>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  
    
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/darmarIT_logo_128.png" alt="Logo"/>
            </a></p>
  

  <h3>Project Links</h3>
  <ul>
    <li><a href="https://return42.github.io/linuxdoc">Home</a>
  
    <li><a href="https://github.com/return42/linuxdoc">Source</a>
  
    <li><a href="https://return42.github.io/linuxdoc/linuxdoc-api/linuxdoc.html">API</a>
  
    <li><a href="https://github.com/return42/linuxdoc">Source</a>
  
    <li><a href="https://github.com/return42/linuxdoc/issues">Issue Tracker</a>
  
    <li><a href="mailto:markus.heiser@darmarIT.de">Contact</a>
  </ul><h3>Navigation</h3>
<ul>
  <li><a href="../../index.html">Overview</a>
    <ul>
      <li><a href="../index.html">Module code</a>
        
          
          </ul>
      </li>
    </ul>
  </li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021 Markus Heiser.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.3.
    </div>
  <script src="../../_static/version_warning_offset.js"></script>

  </body>
</html>