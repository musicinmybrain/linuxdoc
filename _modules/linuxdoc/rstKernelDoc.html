
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>linuxdoc.rstKernelDoc &#8212; LinuxDoc 20200812 documentation</title>
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx_tabs/semantic-ui-2.4.1/segment.min.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx_tabs/semantic-ui-2.4.1/menu.min.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx_tabs/tabs.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.js"></script>
    <script src="../../_static/sphinx_tabs/tabs.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <script>DOCUMENTATION_OPTIONS.URL_ROOT = '../../';</script>
   
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">LinuxDoc 20200812 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for linuxdoc.rstKernelDoc</h1><div class="highlight"><pre>
<span></span># -*- coding: utf-8; mode: python -*-
# pylint: disable=missing-docstring, invalid-name
u&quot;&quot;&quot;
    rstKernelDoc
    ~~~~~~~~~~~~

    Implementation of the ``kernel-doc`` reST-directive.

    :copyright:  Copyright (C) 2018 Markus Heiser
    :license:    GPL Version 2, June 1991 see Linux/COPYING for details.

    The ``kernel-doc`` (:py:class:`KernelDoc`) directive includes contend from
    linux kernel source code comments.

&quot;&quot;&quot;

# ==============================================================================
# imports
# ==============================================================================

import glob
from os import path
from io import StringIO

import six

from docutils import nodes
from docutils.parsers.rst import Directive, directives
from docutils.utils import SystemMessage
from docutils.statemachine import ViewList

from . import compat
from . import kernel_doc as kerneldoc

# ==============================================================================
# common globals
# ==============================================================================

# The version numbering follows numbering of the specification
# (Documentation/books/kernel-doc-HOWTO).
__version__  = &#39;1.0&#39;

PARSER_CACHE = dict()

app_log = compat.getLogger(&#39;application&#39;)

# ==============================================================================
<div class="viewcode-block" id="setup"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.setup">[docs]</a>def setup(app):
# ==============================================================================

    app.add_config_value(&#39;kernel_doc_raise_error&#39;, False, &#39;env&#39;)
    app.add_config_value(&#39;kernel_doc_verbose_warn&#39;, True, &#39;env&#39;)
    app.add_config_value(&#39;kernel_doc_mode&#39;, &quot;reST&quot;, &#39;env&#39;)
    app.add_config_value(&#39;kernel_doc_mansect&#39;, None, &#39;env&#39;)
    app.add_config_value(&#39;kernel_doc_exp_method&#39;, None, &#39;env&#39;)
    app.add_config_value(&#39;kernel_doc_exp_ids&#39;, None, &#39;env&#39;)
    app.add_config_value(&#39;kernel_doc_known_attrs&#39;, None, &#39;env&#39;)
    app.add_directive(&quot;kernel-doc&quot;, KernelDoc)

    return dict(
        version = __version__
        , parallel_read_safe = True
        , parallel_write_safe = True
    )</div>

# ==============================================================================
<div class="viewcode-block" id="KernelDocParser"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.KernelDocParser">[docs]</a>class KernelDocParser(kerneldoc.Parser):
# ==============================================================================

    # pylint: disable=deprecated-method

    def __init__(self, app, *args, **kwargs):
        super(KernelDocParser, self).__init__(*args, **kwargs)
        self.app = app

    # -------------------------------------------------
    # bind the parser logging to the sphinx application
    # -------------------------------------------------

    # pylint: disable=arguments-differ

<div class="viewcode-block" id="KernelDocParser.error"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.KernelDocParser.error">[docs]</a>    def error(self, message, **replace):
        replace[&quot;fname&quot;]   = self.options.fname
        replace[&quot;line_no&quot;] = replace.get(&quot;line_no&quot;, self.ctx.line_no)
        self.errors += 1
        message = (&quot;%(fname)s:%(line_no)s: [kernel-doc ERROR] : &quot; + message) % replace
        app_log.warn(message)</div>

<div class="viewcode-block" id="KernelDocParser.warn"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.KernelDocParser.warn">[docs]</a>    def warn(self, message, **replace):
        replace[&quot;fname&quot;]   = self.options.fname
        replace[&quot;line_no&quot;] = replace.get(&quot;line_no&quot;, self.ctx.line_no)
        self.warnings += 1
        message = (&quot;%(fname)s:%(line_no)s: [kernel-doc WARN] : &quot; + message) % replace
        app_log.warn(message)</div>

<div class="viewcode-block" id="KernelDocParser.info"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.KernelDocParser.info">[docs]</a>    def info(self, message, **replace):
        replace[&quot;fname&quot;]   = self.options.fname
        replace[&quot;line_no&quot;] = replace.get(&quot;line_no&quot;, self.ctx.line_no)
        message = (&quot;%(fname)s:%(line_no)s: [kernel-doc INFO] : &quot; + message) % replace
        app_log.verbose(message)</div>

<div class="viewcode-block" id="KernelDocParser.debug"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.KernelDocParser.debug">[docs]</a>    def debug(self, message, **replace):
        if self.app.verbosity &lt; 2:
            return
        replace[&quot;fname&quot;]   = self.options.fname
        replace[&quot;line_no&quot;] = replace.get(&quot;line_no&quot;, self.ctx.line_no)
        message = (&quot;%(fname)s:%(line_no)s: [kernel-doc DEBUG] : &quot; + message) % replace
        app_log.debug(message)</div></div>


# ==============================================================================
<div class="viewcode-block" id="FaultyOption"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.FaultyOption">[docs]</a>class FaultyOption(Exception):
    pass</div>

<div class="viewcode-block" id="KernelDoc"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.KernelDoc">[docs]</a>class KernelDoc(Directive):
# ==============================================================================

    u&quot;&quot;&quot;KernelDoc (``kernel-doc``) directive&quot;&quot;&quot;

    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = True

    option_spec = {

        # see https://github.com/PyCQA/pylint/issues/289
        # pylint: disable=bad-continuation

        &quot;doc&quot;          : directives.unchanged_required # aka lines containing !P
        , &quot;no-header&quot;  : directives.flag

        , &quot;export&quot;     : directives.unchanged          # aka lines containing !E
        , &quot;internal&quot;   : directives.unchanged          # aka lines containing !I
        , &quot;functions&quot;  : directives.unchanged_required # aka lines containing !F
        , &quot;exp-method&quot; : directives.unchanged_required
        , &quot;exp-ids&quot;    : directives.unchanged_required
        , &quot;known-attrs&quot;: directives.unchanged_required

        , &quot;debug&quot;      : directives.flag               # insert generated reST as code-block

        , &quot;snippets&quot;   : directives.unchanged_required
        , &quot;language&quot;   : directives.unchanged_required
        , &quot;linenos&quot;    : directives.flag

        # module name / used as id-prefix
        , &quot;module&quot;     : directives.unchanged_required
        , &quot;man-sect&quot;   : directives.nonnegative_int

        # The encoding of the source file with the kernel-doc comments. The
        # default is the config.source_encoding from sphinx configuration and
        # this default is utf-8-sig
        , &quot;encoding&quot;   : directives.encoding

    }

<div class="viewcode-block" id="KernelDoc.getParserOptions"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.KernelDoc.getParserOptions">[docs]</a>    def getParserOptions(self):  # pylint: disable=too-many-branches, too-many-statements

        fname     = self.arguments[0]
        src_tree  = kerneldoc.SRCTREE
        exp_files = []  # file pattern to search for EXPORT_SYMBOL
        exp_method  = self.options.get(&quot;exp-method&quot;, self.env.config.kernel_doc_exp_method)
        exp_ids     = self.options.get(&quot;exp-ids&quot;, self.env.config.kernel_doc_exp_ids)
        known_attrs = self.options.get(&quot;known-attrs&quot;, self.env.config.kernel_doc_known_attrs)

        if self.arguments[0].startswith(&quot;./&quot;):
            # the prefix &quot;./&quot; indicates a relative pathname
            fname = self.arguments[0][2:]
            src_tree = path.dirname(path.normpath(self.doc.current_source))

        if &quot;internal&quot; in self.options and &quot;export&quot; in self.options:
            raise FaultyOption(
                &quot;Options &#39;export&#39; and &#39;internal&#39; are orthogonal,&quot;
                &quot; can&#39;t use them togehter&quot;)

        if &quot;snippets&quot; in self.options:
            rest = set(self.options.keys()) - set([&quot;snippets&quot;, &quot;linenos&quot;, &quot;language&quot;, &quot;debug&quot;])
            if rest:
                raise FaultyOption(
                    &quot;kernel-doc &#39;snippets&#39; has non of these options: %s&quot;
                    % &quot;,&quot;.join(rest))

        if self.env.config.kernel_doc_mode not in [&quot;reST&quot;, &quot;kernel-doc&quot;]:
            raise FaultyOption(
                &quot;unknow kernel-doc mode: %s&quot; % self.env.config.kernel_doc_mode)

        # set parse adjustments

        ctx  = kerneldoc.ParserContext()
        opts = kerneldoc.ParseOptions(
            rel_fname       = fname
            , src_tree      = src_tree
            , id_prefix     = self.options.get(&quot;module&quot;, &quot;&quot;).strip()
            , encoding      = self.options.get(&quot;encoding&quot;, self.env.config.source_encoding)
            , verbose_warn  = self.env.config.kernel_doc_verbose_warn
            , markup        = self.env.config.kernel_doc_mode
            , man_sect      = self.options.get(&quot;man-sect&quot;, None)
            , exp_method    = exp_method
            , exp_ids       = (exp_ids or &quot;&quot;).replace(&quot;,&quot;,&quot; &quot;).split()
            , known_attrs   = (known_attrs or &quot;&quot;).replace(&quot;,&quot;,&quot; &quot;).split()
            ,)

        if ( &quot;doc&quot; not in self.options
             and opts.man_sect is None):
            opts.man_sect = self.env.config.kernel_doc_mansect

        opts.set_defaults()

        if not path.exists(opts.fname):
            raise FaultyOption(
                &quot;kernel-doc refers to nonexisting document %s&quot; % opts.fname)

        # always skip preamble and epilog in kernel-doc directives
        opts.skip_preamble = True
        opts.skip_epilog   = True

        if ( &quot;doc&quot; not in self.options
             and &quot;export&quot; not in self.options
             and &quot;internal&quot; not in self.options
             and &quot;functions&quot; not in self.options
             and &quot;snippets&quot; not in self.options ):
            # if no explicit content is selected, then print all, including all
            # DOC sections
            opts.use_all_docs = True

        if &quot;doc&quot; in self.options:
            opts.no_header = bool(&quot;no-header&quot; in self.options)
            opts.use_names.append(self.options.get(&quot;doc&quot;))

        if &quot;export&quot; in self.options:
            # gather exported symbols and add them to the list of names
            kerneldoc.Parser.gather_context(kerneldoc.readFile(opts.fname), ctx, opts)
            exp_files.extend((self.options.get(&#39;export&#39;) or &quot;&quot;).replace(&quot;,&quot;,&quot; &quot;).split())
            opts.error_missing = True

        elif &quot;internal&quot; in self.options:
            # gather exported symbols and add them to the ignore-list of names
            kerneldoc.Parser.gather_context(kerneldoc.readFile(opts.fname), ctx, opts)
            exp_files.extend((self.options.get(&#39;internal&#39;) or &quot;&quot;).replace(&quot;,&quot;,&quot; &quot;).split())

        if &quot;functions&quot; in self.options:
            opts.error_missing = True
            opts.use_names.extend(
                self.options[&quot;functions&quot;].replace(&quot;,&quot;,&quot; &quot;).split())

        for pattern in exp_files:
            if pattern.startswith(&quot;./&quot;): # &quot;./&quot; indicates a relative pathname
                pattern = path.join(
                    path.dirname(path.normpath(self.doc.current_source))
                    , pattern[2:])
            else:
                pattern = path.join(kerneldoc.SRCTREE, pattern)

            if ( not glob.has_magic(pattern)
                 and not path.lexists(pattern) ):
                # if pattern is a filename (is not a glob pattern) and this file
                # does not exists, an error is raised.
                raise FaultyOption(&quot;file not found: %s&quot; % pattern)

            for fname in glob.glob(pattern):
                self.env.note_dependency(path.abspath(fname))
                kerneldoc.Parser.gather_context(kerneldoc.readFile(fname), ctx, opts)

        if &quot;export&quot; in self.options:
            if not ctx.exported_symbols:
                raise FaultyOption(&quot;using option :export: but there are no exported symbols&quot;)
            opts.use_names.extend(ctx.exported_symbols)

        if &quot;internal&quot; in self.options:
            opts.skip_names.extend(ctx.exported_symbols)

        return opts</div>

<div class="viewcode-block" id="KernelDoc.errMsg"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.KernelDoc.errMsg">[docs]</a>    def errMsg(self, msg):
        msg = six.text_type(msg)
        error = self.state_machine.reporter.error(
            msg
            , nodes.literal_block(self.block_text, self.block_text)
            , line = self.lineno )

        # raise exception on error?
        if self.env.config.kernel_doc_raise_error:
            raise SystemMessage(error, 4)

        # insert oops/todo admonition, this is the replacement of the escape
        # sequences &quot;!C&lt;filename&gt; &quot; formerly used in the DocBook-SGML template
        # files.
        todo = (&quot;\n\n.. todo::&quot;
                &quot;\n\n    Oops: Document generation inconsistency.&quot;
                &quot;\n\n    The template for this document tried to insert&quot;
                &quot; structured comment at this point, but an error occoured.&quot;
                &quot; This dummy section is inserted to allow generation to continue.::&quot;
                &quot;\n\n&quot;)

        for l in error.astext().split(&quot;\n&quot;):
            todo +=  &quot;        &quot; + l + &quot;\n&quot;
        todo += &quot;\n\n&quot;
        self.state_machine.insert_input(todo.split(&quot;\n&quot;), self.arguments[0] )</div>

<div class="viewcode-block" id="KernelDoc.parseSource"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.KernelDoc.parseSource">[docs]</a>    def parseSource(self, opts):
        parser = PARSER_CACHE.get(opts.fname, None)

        if parser is None:
            self.env.note_dependency(opts.fname)
            #app_log.info(&quot;parse kernel-doc comments from: %s&quot; % opts.fname)
            parser = KernelDocParser(self.env.app, opts, kerneldoc.NullTranslator())
            parser.parse()
            PARSER_CACHE[opts.fname] = parser
        else:
            parser.setOptions(opts)

        return parser</div>

<div class="viewcode-block" id="KernelDoc.run"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.KernelDoc.run">[docs]</a>    def run(self):

        # FIXME: think about again; these members has been added for convenience
        self.parser = None                     # pylint: disable=attribute-defined-outside-init
        self.doc    = self.state.document      # pylint: disable=attribute-defined-outside-init
        self.env    = self.doc.settings.env    # pylint: disable=attribute-defined-outside-init
        self.nodes  = []                       # pylint: disable=attribute-defined-outside-init

        try:
            if not self.doc.settings.file_insertion_enabled:
                raise FaultyOption(&#39;docutils: file insertion disabled&#39;)
            opts = self.getParserOptions()
            # FIXME: think about again; these members has been added for convenience
            self.parser = self.parseSource(opts) # pylint: disable=attribute-defined-outside-init
            self.nodes.extend(self.getNodes())

        except FaultyOption as exc:
            self.errMsg(exc)

        return self.nodes</div>


<div class="viewcode-block" id="KernelDoc.getNodes"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.KernelDoc.getNodes">[docs]</a>    def getNodes(self):  # pylint: disable=too-many-branches, too-many-statements, too-many-locals

        translator = kerneldoc.ReSTTranslator()
        lines      = &quot;&quot;
        content    = WriterList(self.parser)

        # translate

        if &quot;debug&quot; in self.options:
            rstout = StringIO()
            self.parser.options.out = rstout
            self.parser.parse_dump_storage(translator=translator)
            code_block = &quot;\n\n.. code-block:: rst\n    :linenos:\n&quot;
            for l in rstout.getvalue().split(&quot;\n&quot;):
                code_block += &quot;\n    &quot; + l
            lines = code_block + &quot;\n\n&quot;

        elif &quot;snippets&quot; in self.options:
            selected  = self.options[&quot;snippets&quot;].replace(&quot;,&quot;,&quot; &quot;).split()
            names     = self.parser.ctx.snippets.keys()
            not_found = [ s for s in selected if s not in names]
            found     = [ s for s in selected if s in names]
            if not_found:
                self.errMsg(&quot;selected snippets(s) not found:\n    %s&quot;
                            % &quot;\n    ,&quot;.join(not_found))

            if found:
                code_block = &quot;\n\n.. code-block:: %s\n&quot; % self.options.get(&quot;language&quot;, &quot;c&quot;)
                if &quot;linenos&quot; in self.options:
                    code_block += &quot;    :linenos:\n&quot;
                snipsnap = &quot;&quot;
                while found :
                    snipsnap += self.parser.ctx.snippets[found.pop(0)] + &quot;\n\n&quot;
                for l in snipsnap.split(&quot;\n&quot;):
                    code_block += &quot;\n    &quot; + l
                lines = code_block + &quot;\n\n&quot;

        else:
            self.parser.options.out = content
            self.parser.parse_dump_storage(translator=translator)

        # check translation

        if &quot;functions&quot; in self.options:
            selected  = self.options[&quot;functions&quot;].replace(&quot;,&quot;,&quot; &quot;).split()
            names     = translator.translated_names
            not_found = [ s for s in selected if s not in names]
            if not_found:
                self.errMsg(
                    &quot;selected section(s) not found:\n    %s&quot;
                    % &quot;\n    ,&quot;.join(not_found))

        if &quot;export&quot; in self.options:
            selected  = self.parser.options.use_names
            names     = translator.translated_names
            not_found = [ s for s in selected if s not in names]
            if not_found:
                self.errMsg(
                    &quot;exported definitions not found:\n    %s&quot;
                    % &quot;\n    ,&quot;.join(not_found))

        # add lines to content list
        reSTfname = self.state.document.current_source

        content.flush()
        if lines:
            for l in lines.split(&quot;\n&quot;):
                content.append(l, reSTfname, self.lineno)

        node = nodes.section()
        # necessary so that the child nodes get the right source/line set
        node.document = self.state.document
        with compat.switch_source_input(self.state, content):
            # hack around title style bookkeeping
            buf = self.state.memo.title_styles, self.state.memo.section_level
            self.state.memo.title_styles, self.state.memo.section_level = [], 0
            try:
                self.state.nested_parse(content, 0, node, match_titles=1)
            finally:
                self.state.memo.title_styles, self.state.memo.section_level = buf
        return node.children</div></div>


# ==============================================================================
<div class="viewcode-block" id="WriterList"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.WriterList">[docs]</a>class WriterList(ViewList):
# ==============================================================================
    u&quot;&quot;&quot;docutils ViewList with write method.&quot;&quot;&quot;

    def __init__(self, parser, *args, **kwargs):
        ViewList.__init__(self, *args, **kwargs)
        self.parser = parser

        self.last_offset = -1
        self.line_buffer = &quot;&quot;

<div class="viewcode-block" id="WriterList.write"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.WriterList.write">[docs]</a>    def write(self, cont):
        if self.last_offset != self.parser.ctx.offset:
            self.flush()
            self.line_buffer = &quot;&quot;
            self.last_offset = self.parser.ctx.offset

        self.line_buffer += cont</div>

<div class="viewcode-block" id="WriterList.flush"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.rstKernelDoc.html#linuxdoc.rstKernelDoc.WriterList.flush">[docs]</a>    def flush(self):
        for _i, l in enumerate(self.line_buffer.split(&quot;\n&quot;)):
            self.append(l, self.parser.options.fname, self.last_offset)
        self.line_buffer = &quot;&quot;</div></div>
</pre></div>

          </div>
        </div>
      </div>
  <span id="sidebar-top"></span>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  
    
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/darmarIT_logo_128.png" alt="Logo"/>
            </a></p>
  

  <h3>Project Links</h3>
  <ul>
    <li><a href="https://return42.github.io/linuxdoc">Home</a>
  
    <li><a href="https://github.com/return42/linuxdoc">Source</a>
  
    <li><a href="https://return42.github.io/linuxdoc/linuxdoc-api/linuxdoc.html">API</a>
  </ul><h3>Navigation</h3>
<ul>
  <li><a href="../../index.html">Overview</a>
    <ul>
      <li><a href="../index.html">Module code</a>
        
          
          </ul>
      </li>
    </ul>
  </li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020 Markus Heiser.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>
  <script src="../../_static/version_warning_offset.js"></script>

  </body>
</html>