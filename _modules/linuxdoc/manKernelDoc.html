
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>linuxdoc.manKernelDoc &#8212; LinuxDoc 20210324 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/tabs.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <script>DOCUMENTATION_OPTIONS.URL_ROOT = '../../';</script>
   
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">LinuxDoc 20210324 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">linuxdoc.manKernelDoc</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for linuxdoc.manKernelDoc</h1><div class="highlight"><pre>
<span></span>#!/usr/bin/env python3
# -*- coding: utf-8; mode: python -*-
# SPDX-License-Identifier: GPL-2.0
# pylint: disable=missing-docstring, invalid-name, unnecessary-pass
&quot;&quot;&quot;\
kernel-doc-man
~~~~~~~~~~~~~~

Implementation of the ``kernel-doc-man`` builder.

User documentation see :ref:`man-pages`.
&quot;&quot;&quot;

# ==============================================================================
# imports
# ==============================================================================

import re
import collections
from os import path

from docutils.io import FileOutput
from docutils.frontend import OptionParser
from docutils import nodes
from docutils.utils import new_document
from docutils.parsers.rst import Directive
from docutils.transforms import Transform

from sphinx import addnodes
from sphinx.util import logging
from sphinx.util.nodes import inline_all_toctrees
from sphinx.util.console import bold, darkgreen  # pylint: disable=no-name-in-module
from sphinx.writers.manpage import ManualPageWriter

from sphinx.builders.manpage import ManualPageBuilder

from .kernel_doc import Container
from . import compat

logger = logging.getLogger(__name__)

# ==============================================================================
# common globals
# ==============================================================================

DEFAULT_MAN_SECT  = 9

# The version numbering follows numbering of the specification
# (Documentation/books/kernel-doc-HOWTO).
__version__  = &#39;1.0&#39;

# ==============================================================================
<div class="viewcode-block" id="setup"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.setup">[docs]</a>def setup(app):
# ==============================================================================

    app.add_builder(KernelDocManBuilder)
    app.add_directive(&quot;kernel-doc-man&quot;, KernelDocMan)
    app.add_node(kernel_doc_man
                 , html    = (skip_kernel_doc_man, None)
                 , latex   = (skip_kernel_doc_man, None)
                 , texinfo = (skip_kernel_doc_man, None)
                 , text    = (skip_kernel_doc_man, None)
                 , man     = (skip_kernel_doc_man, None) )

    return dict(
        version = __version__
        , parallel_read_safe = True
        , parallel_write_safe = True
    )</div>

# ==============================================================================
<div class="viewcode-block" id="kernel_doc_man"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.kernel_doc_man">[docs]</a>class kernel_doc_man(  # pylint: disable=invalid-name
        nodes.Invisible, nodes.Element):
# ==============================================================================
    &quot;&quot;&quot;Node to mark a section as *manpage*&quot;&quot;&quot;</div>

<div class="viewcode-block" id="skip_kernel_doc_man"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.skip_kernel_doc_man">[docs]</a>def skip_kernel_doc_man(self, node):  # pylint: disable=unused-argument
    raise nodes.SkipNode</div>


# ==============================================================================
<div class="viewcode-block" id="KernelDocMan"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.KernelDocMan">[docs]</a>class KernelDocMan(Directive):
# ==============================================================================

    required_arguments = 1
    optional_arguments = 0

<div class="viewcode-block" id="KernelDocMan.run"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.KernelDocMan.run">[docs]</a>    def run(self):
        man_node = kernel_doc_man()
        man_node[&quot;manpage&quot;] = self.arguments[0]
        return [man_node]</div></div>

# ==============================================================================
<div class="viewcode-block" id="Section2Manpage"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.Section2Manpage">[docs]</a>class Section2Manpage(Transform):
# ==============================================================================
    u&quot;&quot;&quot;Transforms a *section* tree into an *manpage* tree.

    The structural layout of a man-page differs from the one produced, by the
    kernel-doc parser.  The kernel-doc parser produce reST which fits to *normal*
    documentation, e.g. the declaration of a function in reST is like.

    .. code-block:: rst

        user_function
        =============

        .. c:function:: int user_function(int a)

           The *purpose* description.

           :param int a:
               Parameter a description

       Description
       ===========

       lorem ipsum ..

       Return
       ======

       Returns first argument

    On the other side, in man-pages it is common (see ``man man-pages``) to
    print the *purpose* line in the &quot;NAME&quot; section, function&#39;s prototype in the
    &quot;SYNOPSIS&quot; section and the parameter description in the &quot;OPTIONS&quot; section::

       NAME
              user_function -- The *purpose* description.

       SYNOPSIS
               int user_function(int a)

       OPTIONS
               a

       DESCRIPTION
               lorem ipsum

       RETURN VALUE
               Returns first argument

    &quot;&quot;&quot;
    # The common section order is:
    manTitles = [
        (re.compile(r&quot;^SYNOPSIS|^DEFINITION&quot;
                    , flags=re.I), &quot;SYNOPSIS&quot;)
        , (re.compile(r&quot;^CONFIG&quot;,     flags=re.I), &quot;CONFIGURATION&quot;)
        , (re.compile(r&quot;^DESCR&quot;,      flags=re.I), &quot;DESCRIPTION&quot;)
        , (re.compile(r&quot;^OPTION&quot;,     flags=re.I), &quot;OPTIONS&quot;)
        , (re.compile(r&quot;^EXIT&quot;,       flags=re.I), &quot;EXIT STATUS&quot;)
        , (re.compile(r&quot;^RETURN&quot;,     flags=re.I), &quot;RETURN VALUE&quot;)
        , (re.compile(r&quot;^ERROR&quot;,      flags=re.I), &quot;ERRORS&quot;)
        , (re.compile(r&quot;^ENVIRON&quot;,    flags=re.I), &quot;ENVIRONMENT&quot;)
        , (re.compile(r&quot;^FILE&quot;,       flags=re.I), &quot;FILES&quot;)
        , (re.compile(r&quot;^VER&quot;,        flags=re.I), &quot;VERSIONS&quot;)
        , (re.compile(r&quot;^ATTR&quot;,       flags=re.I), &quot;ATTRIBUTES&quot;)
        , (re.compile(r&quot;^CONFOR&quot;,     flags=re.I), &quot;CONFORMING TO&quot;)
        , (re.compile(r&quot;^NOTE&quot;,       flags=re.I), &quot;NOTES&quot;)
        , (re.compile(r&quot;^BUG&quot;,        flags=re.I), &quot;BUGS&quot;)
        , (re.compile(r&quot;^EXAMPLE&quot;,    flags=re.I), &quot;EXAMPLE&quot;)
        , (re.compile(r&quot;^SEE&quot;,        flags=re.I), &quot;SEE ALSO&quot;)
        , ]

    manTitleOrder = [t for r,t in manTitles]

<div class="viewcode-block" id="Section2Manpage.sec2man_get_first_child"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.Section2Manpage.sec2man_get_first_child">[docs]</a>    @classmethod
    def sec2man_get_first_child(cls, subtree, *classes):
        for _c in classes:
            if subtree is None:
                break
            idx = subtree.first_child_matching_class(_c)
            if idx is None:
                subtree = None
                break
            subtree = subtree[idx]
        return subtree</div>

<div class="viewcode-block" id="Section2Manpage.strip_man_info"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.Section2Manpage.strip_man_info">[docs]</a>    def strip_man_info(self):
        section  = self.document[0]
        man_info = Container(authors=[])
        man_node = self.sec2man_get_first_child(section, kernel_doc_man)
        name, sect = (man_node[&quot;manpage&quot;].split(&quot;.&quot;, -1) + [DEFAULT_MAN_SECT])[:2]
        man_info[&quot;manpage&quot;] = name
        man_info[&quot;mansect&quot;] = sect

        # strip field list
        field_list = self.sec2man_get_first_child(section, nodes.field_list)
        if field_list:
            field_list.parent.remove(field_list)
            for field in field_list:
                name  = field[0].astext().lower()
                value = field[1].astext()
                man_info[name] = man_info.get(name, []) + [value,]

            # normalize authors
            for auth, adr in zip(man_info.get(&quot;author&quot;, [])
                                 , man_info.get(&quot;address&quot;, [])):
                man_info[&quot;authors&quot;].append(&quot;%s &lt;%s&gt;&quot; % (auth, adr))

        # strip *purpose*
        desc_content = self.sec2man_get_first_child(
            section, addnodes.desc, addnodes.desc_content)
        if not desc_content or not len(desc_content): # pylint: disable=len-as-condition
            # missing initial short description in kernel-doc comment
            man_info.subtitle = &quot;&quot;
        else:
            man_info.subtitle = desc_content[0].astext()
            del desc_content[0]

        # remove section title
        old_title = self.sec2man_get_first_child(section, nodes.title)
        old_title.parent.remove(old_title)

        # gather type of the declaration
        decl_type = self.sec2man_get_first_child(
            section, addnodes.desc, addnodes.desc_signature, addnodes.desc_type)
        if decl_type is not None:
            decl_type = decl_type.astext().strip()
        man_info.decl_type = decl_type

        # complete infos
        man_info.title    = man_info[&quot;manpage&quot;]
        man_info.section  = man_info[&quot;mansect&quot;]

        return man_info</div>

<div class="viewcode-block" id="Section2Manpage.isolate_sections"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.Section2Manpage.isolate_sections">[docs]</a>    def isolate_sections(self, sec_by_title):
        section = self.document[0]
        while True:
            sect = self.sec2man_get_first_child(section, nodes.section)
            if not sect:
                break
            sec_parent = sect.parent
            target_idx = sect.parent.index(sect) - 1
            sect.parent.remove(sect)
            if isinstance(sec_parent[target_idx], nodes.target):
                # drop target / is useless in man-pages
                del sec_parent[target_idx]
            title = sect[0].astext().upper()
            for r, man_title in self.manTitles:  # pylint: disable=invalid-name
                if r.search(title):
                    title = man_title
                    sect[0].replace_self(nodes.title(text = title))
                    break
            # we dont know if there are sections with the same title
            sec_by_title[title] = sec_by_title.get(title, []) + [sect]

        return sec_by_title</div>

<div class="viewcode-block" id="Section2Manpage.isolate_synopsis"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.Section2Manpage.isolate_synopsis">[docs]</a>    def isolate_synopsis(self, sec_by_title):
        synopsis = None
        c_desc = self.sec2man_get_first_child(self.document[0], addnodes.desc)
        if c_desc is not None:
            c_desc.parent.remove(c_desc)
            synopsis = nodes.section()
            synopsis += nodes.title(text = &#39;synopsis&#39;)
            synopsis += c_desc
            sec_by_title[&quot;SYNOPSIS&quot;] = sec_by_title.get(&quot;SYNOPSIS&quot;, []) + [synopsis]
        return sec_by_title</div>

<div class="viewcode-block" id="Section2Manpage.apply"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.Section2Manpage.apply">[docs]</a>    def apply(self, **kwargs):
        self.document.man_info = self.strip_man_info()
        sec_by_title = collections.OrderedDict()

        self.isolate_sections(sec_by_title)
        # On struct, enum, union, typedef, the SYNOPSIS is taken from the
        # DEFINITION section.
        if self.document.man_info.decl_type not in [
                &quot;struct&quot;, &quot;enum&quot;, &quot;union&quot;, &quot;typedef&quot;]:
            self.isolate_synopsis(sec_by_title)

        for sec_name in self.manTitleOrder:
            sec_list = sec_by_title.pop(sec_name,[])
            self.document[0] += sec_list

        for sec_list in sec_by_title.values():
            self.document[0] += sec_list</div></div>

# ==============================================================================
<div class="viewcode-block" id="KernelDocManBuilder"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.KernelDocManBuilder">[docs]</a>class KernelDocManBuilder(ManualPageBuilder):
# ==============================================================================

    &quot;&quot;&quot;
    Builds groff output in manual page format.
    &quot;&quot;&quot;
    name = &#39;kernel-doc-man&#39;
    format = &#39;man&#39;
    supported_image_types = []

<div class="viewcode-block" id="KernelDocManBuilder.init"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.KernelDocManBuilder.init">[docs]</a>    def init(self):
        pass</div>

<div class="viewcode-block" id="KernelDocManBuilder.is_manpage"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.KernelDocManBuilder.is_manpage">[docs]</a>    def is_manpage(self, node):  # pylint: disable=no-self-use
        if isinstance(node, nodes.section):
            return bool(
                Section2Manpage.sec2man_get_first_child(
                    node, kernel_doc_man) is not None)
        return False</div>

<div class="viewcode-block" id="KernelDocManBuilder.prepare_writing"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.KernelDocManBuilder.prepare_writing">[docs]</a>    def prepare_writing(self, docnames):
        &quot;&quot;&quot;A place where you can add logic before :meth:`write_doc` is run&quot;&quot;&quot;
        pass</div>

<div class="viewcode-block" id="KernelDocManBuilder.write_doc"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.KernelDocManBuilder.write_doc">[docs]</a>    def write_doc(self, docname, doctree):
        &quot;&quot;&quot;Where you actually write something to the filesystem.&quot;&quot;&quot;
        pass</div>

<div class="viewcode-block" id="KernelDocManBuilder.get_partial_document"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.KernelDocManBuilder.get_partial_document">[docs]</a>    def get_partial_document(self, children):  # pylint: disable=no-self-use
        doc_tree =  new_document(&#39;&lt;output&gt;&#39;)
        doc_tree += children
        return doc_tree</div>

<div class="viewcode-block" id="KernelDocManBuilder.write"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.KernelDocManBuilder.write">[docs]</a>    def write(self, *ignored):
        if self.config.man_pages:
            # build manpages from config.man_pages as usual
            ManualPageBuilder.write(self, *ignored)

        logger.info(bold(&quot;scan master tree for kernel-doc man-pages ... &quot;) + darkgreen(&quot;{&quot;), nonl=True)

        master_tree = self.env.get_doctree(self.config.master_doc)
        master_tree = inline_all_toctrees(
            self, set(), self.config.master_doc, master_tree, darkgreen, [self.config.master_doc])
        logger.info(darkgreen(&quot;}&quot;))
        man_nodes   = master_tree.traverse(condition=self.is_manpage)
        if not man_nodes and not self.config.man_pages:
            logger.warn(&#39;no &quot;man_pages&quot; config value nor manual section found; no manual pages &#39;
                        &#39;will be written&#39;)
            return

        logger.info(bold(&#39;START writing man pages ... &#39;), nonl=True)

        for man_parent in man_nodes:

            doc_tree = self.get_partial_document(man_parent)
            Section2Manpage(doc_tree).apply()

            if not doc_tree.man_info[&quot;authors&quot;] and self.config.author:
                doc_tree.man_info[&quot;authors&quot;].append(self.config.author)

            doc_writer   = ManualPageWriter(self)
            doc_settings = OptionParser(
                defaults            = self.env.settings
                , components        = (doc_writer,)
                , read_config_files = True
                , ).get_default_values()

            doc_settings.__dict__.update(doc_tree.man_info)
            doc_tree.settings = doc_settings
            targetname  = &#39;%s.%s&#39; % (doc_tree.man_info.title, doc_tree.man_info.section)
            if doc_tree.man_info.decl_type in [
                    &quot;struct&quot;, &quot;enum&quot;, &quot;union&quot;, &quot;typedef&quot;]:
                targetname = &quot;%s_%s&quot; % (doc_tree.man_info.decl_type, targetname)

            destination = FileOutput(
                destination_path = path.join(self.outdir, targetname)
                , encoding=&#39;utf-8&#39;)

            logger.info(darkgreen(targetname) + &quot; &quot;, nonl=True)
            self.env.resolve_references(doc_tree, doc_tree.man_info.manpage, self)

            # remove pending_xref nodes
            for pendingnode in doc_tree.traverse(addnodes.pending_xref):
                pendingnode.replace_self(pendingnode.children)
            doc_writer.write(doc_tree, destination)
        logger.info(&quot;END writing man pages.&quot;)</div>


<div class="viewcode-block" id="KernelDocManBuilder.finish"><a class="viewcode-back" href="../../linuxdoc-api/linuxdoc.manKernelDoc.html#linuxdoc.manKernelDoc.KernelDocManBuilder.finish">[docs]</a>    def finish(self):
        pass</div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
  <span id="sidebar-top"></span>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  
    
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/darmarIT_logo_128.png" alt="Logo"/>
            </a></p>
  

  <h3>Project Links</h3>
  <ul>
    <li><a href="https://return42.github.io/linuxdoc">Home</a>
  
    <li><a href="https://github.com/return42/linuxdoc">Source</a>
  
    <li><a href="https://return42.github.io/linuxdoc/linuxdoc-api/linuxdoc.html">API</a>
  
    <li><a href="https://github.com/return42/linuxdoc">Source</a>
  
    <li><a href="https://github.com/return42/linuxdoc/issues">Issue Tracker</a>
  
    <li><a href="mailto:markus.heiser@darmarIT.de">Contact</a>
  </ul><h3>Navigation</h3>
<ul>
  <li><a href="../../index.html">Overview</a>
    <ul>
      <li><a href="../index.html">Module code</a>
        
          
          </ul>
      </li>
    </ul>
  </li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021 Markus Heiser.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.3.
    </div>
  <script src="../../_static/version_warning_offset.js"></script>

  </body>
</html>